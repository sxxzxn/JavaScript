<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1>자바스크립트</h1>
    <p>동적으로 변경되는 콘텐츠를 만들고, 멀티미디어를 제어하고, 이미지에 애니메이션을 적용하는 등 거의 모든 작업을 수행할 수 있는 스크립팅 언어</p>

    <h2>자바스크립트의 특징</h2>
    <ul>
        <li>웹 어플리케이션을 만들 수 있다.</li>
        <li>다양한 라이브러리 사용 가능</li>
        <li>서버 개발 가능</li>
    </ul>

    <h2>자바스크립트 사용법</h2>
    <p>웹 문서 안에서 작성 : <code>&lt;script&gt;&lt;/script&gt;</code> 안에 내용을 적으면 됨</p>
    <p>외부 스크립트 파일로 연결해서 작성</p>
    <p><code>&lt;script src="파일경로"&gt;&lt;/script&gt;</code></p>

    <h2>자바스크립트 작성법</h2>
    <p>스타일 가이드나 코딩컨벤션, (코딩스타일, 표준스타일)를 따라 작성한다</p>
    <ol>
        <li>코드를 보기 좋게 들여쓰기</li>
        <li>세미콜론으로 문장 구분</li>
        <li>공백을 넣어 읽기 쉽게 작성</li>
        <li>소스코드 설명하는 주석 작성</li>
        <li>식별자는 정해진 규칙에 따라 작성
            <ul>
                <li>첫 글자는 영어, _, $ 작성 가능하며</li>
                <li>영어, _, $, 숫자 사용 가능 (공백 사용 불가)</li>
            </ul>
        </li>
        <li>예약어는 식별자로 사용 불가</li>
    </ol>

    <h2>자바스크립트의 기본 문법</h2>

    <h3>변수</h3>
    <p>프로그램을 실행하는 동안 값이 여러번 달라질 수 있는 데이터</p>

    <h3>변수 선언 규칙</h3>
    <ol>
        <li>변수 이름은 영어 , _, 숫자 사용 가능</li>
        <li>영어 대소문자 구분</li>
        <li>카멜표기법 사용</li>
        <li>의미 있게 작성</li>
    </ol>

    <h3>상수</h3>
    <p>값을 한번 지정하면 변하지 않는 값</p>

    <h3>자료형</h3>
    <ul>
        <li>숫자형
            <ul>
                <li>숫자 형태의 데이터를 처리</li>
                <li>정수 : 1, 0, -1 등 소숫점이 붙지 않은 숫자</li>
                <li>실수 : 0.1, 2.1 등 소숫점이 붙은 숫자
                    <ul>
                        <li>단, 실수의 소숫점 이하 자리수에 대한 정밀도 보장 x</li>
                    </ul>
                </li>
            </ul>
        </li>
        <li>문자열(string)
            <ul>
                <li>문자가 한 개 이상 이어져 있는 것</li>
                <li>‘a’, ‘aa’ 등등</li>
            </ul>
        </li>
        <li>논리형(boolean)
            <ul>
                <li>true, false 반환</li>
            </ul>
        </li>
        <li>기본 유형
            <ul>
                <li>undefined
                    <ul>
                        <li>자료형이 선언되지 않았을 때 데이터</li>
                        <li>변수 선언만 하고 값이 할당되지 않은 상태</li>
                    </ul>
                </li>
                <li>null
                    <ul>
                        <li>데이터 값이 유효하지 않은 상태</li>
                        <li>변수에 할당된 값이 유효하지 않다는 의미</li>
                    </ul>
                </li>
            </ul>
        </li>
        <li>특수 유형
            <ul>
                <li>배열(array)
                    <ul>
                        <li>하나의 변수에 여러 값 저장 가능</li>
                        <li>자료형의 유형이 같은 값을 할당</li>
                    </ul>
                </li>
                <li>객체(object)
                    <ul>
                        <li>배열, 함수, 객체 리터럴 등으로 파생되는 상위 자료형</li>
                        <li>객체 리터럴 : {}를 사용, 키와 값으로 이루어진 데이터</li>
                    </ul>
                </li>
            </ul>
        </li>
        <li>복합 유형</li>
    </ul>

    <h3>연산자</h3>
    <ul>
        <li>산술 연산자 : + - / * % ++ --</li>
        <li>할당 연산자(대입 연산자) =, +=, -=, /=, %=</li>
        <li>비교 연산자 ==, ===(자료형까지 비교) !=(부정형 비교)</li>
        <li>논리 연산자(boolean) : or||, and:&&, not!</li>
    </ul>

    <h2>조건문</h2>
    <p>if(조건) {<br>
        조건이 맞을 때 실행할 명령<br>
    }<br>
    else {<br>
        그 외 상황에서 실행할 명령<br>
    }</p>
    <p>(조건) ? true일 때 실행할 명령 : false일 때 실행할 명령</p>
    <p>조건이 하나고 true와 false로 간단할 때 이렇게 작성 가능!</p>

    <p>switch : case를 사용하여 여러 개의 조건에 따라 사용 가능</p>
    <p>switch(조건) {<br>
        case "해당 조건" : 명령<br>
        break;<br>
        case "해당 조건" : 명령<br>
        break;<br>
        case "해당 조건" : 명령<br>
        break;<br>
        ...<br>
        default : 명령<br>
    }</p>

    <h2>반복문</h2>
    <p>for (초기값; 조건; 증가식) {<br>
        실행 명령<br>
    }</p>

    <h3>for of</h3>
    <p>for (let 변수명 of 확인할 배열)<br>
    배열의 값 확인 가능(실제 값!)<br>
    예: name: coco, name: hani</p>

    <h3>for in</h3>
    <p>for (let 변수명 in 확인할 배열)<br>
    배열의 인덱스 확인 가능<br>
    예: 0, 1<br>
    dog = { name: coco, name: hani }</p>

    <h3>기본 for 문</h3>
    <p>인덱스를 사용하여 배열을 순회</p>
    <pre>
    const arrScore2 = [30, 50, 70, 80, 90, 75]; // 점수 배열
    let sum2 = 0; // 점수 합계를 저장할 변수
    let fin2 = 0; // 평균을 저장할 변수

    for (let score of arrScore2) {
      sum2 += score; // 각 점수를 sum2에 더합니다.
    }

    fin2 = sum2 / arrScore2.length;

    document.write("for of 평균: " + fin2 + "&lt;br&gt;");
    </pre>

    <h3>for...of 문</h3>
    <p>배열의 값을 직접 순회. 가장 간편하고 직관적인 방법</p>
    <pre>
    const arrScore3 = [30, 50, 70, 80, 90, 75]; // 점수 배열
    let sum3 = 0; // 점수 합계를 저장할 변수

    for (let index in arrScore3) {
      sum3 += arrScore3[index]; // 현재 인덱스의 점수를 sum3에 더합니다.
    }

    let fin3 = sum3 / arrScore3.length;

    document.write("for in 평균: " + fin3);
    </pre>

    <h3>for...in 문</h3>
    <p>인덱스를 순회하며, 배열의 경우에는 권장되지 않음. 주로 객체의 속성을 반복할 때 사용</p>

    <h3>while, do~while</h3>
    <p>while(조건) {<br>
    실행 명령<br>
    }</p>
    <p>do {<br>
    실행 명령<br>
    } while(조건)</p>
    <p>차이점! do while는 무조건 한 번 실행 후 조건을 확인하여 다시 실행할지 결정하고 while조건을 먼저 확인해서 안 맞으면 실행 자체x</p>

    <h3>break</h3>
    <p>동작 멈추고 빠져나가기</p>
    <h3>continue</h3>
    <p>한 번만 건너 뛰고 다음으로 넘어가기</p>

    <h2>함수와 이벤트</h2>

    <h3>함수</h3>
    <p>동작해야 할 목적대로 묶은 명령</p>
    <p>어떤 목적을 가지고 작성한 코드를 모아놓은 블록문</p>
    <p>각 명령의 시작과 끝을 정확히 구분할 수 있음</p>

    <h3>함수 사용법</h3>
    <p>function 함수명 (변수) {<br>
    실행할 동작들(for, if 등등)<br>
    }</p>
    <p>이렇게 하고 하단에 함수명(변수) 하면 함수 호출임!</p>

    <h3>변수의 특징(호이스팅)</h3>
    <p>지역변수 (로컬변수) : 한 함수 안에서만 사용</p>
    <p>전역변수 (글로벌변수) : 스크립트 소스 전체에서 사용</p>
    <p>var는 지역변수로 하단에서 작성해도 해당 작성을 자바스크립트가 기억하고 위로 끌어올리는 현상이 발생함 : 호이스팅 현상!</p>
    <p>호이스팅 : 상황에 따라 변수의 선언과 할당을 분리해 선언을 스코프의 가장 위로 끌어 올리는 현상</p>
    <p>스코프 : 변수가 적용되는 범위</p>
    <p>해당 호이스팅 현상을 막기 위해 블록 안에서만 사용하는 변수 let와 const를 사용</p>
    <p>var : 함수단위</p>
    <p>let, const : {} ← 블록 영역 안에서만 사용</p>
    <p>let: 재선언 x, 재할당 O<br>
    const(상수변수) : 재선언 x, 재할당 x</p>

    <h3>변수 사용법</h3>
    <ol>
        <li>전역 변수 사용 최소화</li>
        <li>var는 함수 시작 부분에서 사용(호이스팅 방지)</li>
        <li>for문 안에서 카운터 변수는 var 사용 금지</li>
        <li>es6에서는 var 말고 let 사용</li>
    </ol>

    <h3>함수 재사용</h3>
    <p>값을 함수에 직접 대입하는 것이 아니라 매개변수로 처음 값을 넣어주고 추후 매개변수에 값을 넣으면 유동적으로 사용이 가능하다</p>

    <h3>함수표현식</h3>
    <ol>
        <li>익명 함수
            <ul>
                <li>함수명이 없이 사용</li>
                <li>변수명에 할당해 변수를 함수처럼 사용</li>
                <li>let 변수명 function (매개변수) {}</li>
                <li>변수명 ( 매개변수,,,,)</li>
                <li>변수명 (10,20)</li>
                <li>function sum(매개변수1, 매개변수2) { }, sum(10,20)</li>
            </ul>
            <pre>
            /* 익명 함수 : 이름을 붙이지 않고 사용 */

             function(a, b) {
              return a + b;
            }
            //기본형 
         
            let sum = function(a, b) {
              return a + b;
            }
            document.write(sum(5,1));
            바로 할당해서 사용
            
            결과값 6
            </pre>
        </li>
        <li>네이밍 함수
            <ul>
                <li>익명 함수와 유사</li>
                <li>변수에 할당하는 함수에 식별자가 있을 때</li>
                <li>const 변수명 = function 이름() {};</li>
                <li>변수명으로만 참조 가능</li>
            </ul>
        </li>
        <li>즉시 실행 함수
            <ul>
                <li>기본 함수를 (기본함수 ~~)로 감싸서 사용</li>
                <li>페이지 로딩 시 즉시 실행</li>
                <li>(function() { 실행구문; }()); : 기본형</li>
                <li>(function(매개변수,,,,) { 실행구문,,, }(인수)); : 확장형
                    <ul>
                        <li>인수 안에 이벤트 넣어주기</li>
                        <li>페이지가 실행될 때 자동으로 즉시 실행</li>
                    </ul>
                </li>
                <pre>
                (function() {
                  명령
                }());
                
                (function (매개변수) {
                  명령
                }(인수));
                기본형
                
                (function(){
                  let name = prompt("이름");
                  document.write("안녕"+name);
                }());
                
                (function(a,b){
                sum = a + b;
                }(100,200));
                document.write(sum+"&lt;br&gt;");
                
                이건 익명 함수인데 위랑 결과는 똑같음 !
                let summ = function(a, b) {
                      return a + b;
                    }
                    document.write(summ(5,1));
                </pre>
            </ul>
        </li>
        <li>화살표 함수
            <ul>
                <li>(매개변수) ⇒ {함수 내용}</li>
                <li>ES6 정의</li>
                <li>=>{}</li>
                <li>const sum = ()=>{로직}; sum();</li>
                <li>onclick="(e)=>{e.target...}" 이런 식으로 사용</li>
                <li>클릭 한 번에만 사용!</li>
                <pre>
                /* 화살표 함수 */
                (매개변수) => {함수 내용}
                
                //1
                const hi = function() {
                  return "안녕";
                }
                document.write(hi());
                
                //2
                const hi =() => {return "안ㅇㅇ녕"};
                document.write(hi());
                
                //3
                const hi = () => "안녕";
                document.write(hi());
                
                1->2->3 순으로 정리 가능!
                
                /* 익명 함수 -> 화살표 함수 */
                let sum = function(a,b){
                  return a+b;
                }
                
                document.write(sum(5,7))
                
                let sum = (a,b) => a+b;
                document.write(sum(5,10));
                
                제일 하단이 최종형...
                </pre>
            </ul>
        </li>
    </ol>

    <h2>이벤트와 이벤트 처리기</h2>

    <h3>이벤트</h3>
    <ul>
        <li>이벤트 : 웹 브라우저나 사용자가 행하는 동작</li>
        <li>웹 문서(DOM) 영역 안에서 발생하는 동작</li>
        <li>마우스, 키보드, 웹 문서 로딩 시, 폼 내용 작성 등</li>
        <li>HTML에서 가상 클래스로 사용했던 것들</li>
        <li>사용자의 동작과 관련</li>
        <li>(폼, li, 메뉴 영역)</li>
    </ul>

    <h3>이벤트의 종류</h3>
    <ul>
        <li>마우스 관련 이벤트 요소
            <ul>
                <li>onclick : HTML 요소, 영역을 클릭할 때 발생</li>
                <li>ondbclick : 두 번 클릭할 때 발생</li>
                <li>onmouseover : 요소 위에서 마우스 버튼을 눌렀을 때</li>
                <li>onmouseout : 요소를 벗어날 때</li>
                <li>onmousemove : 요소 위에서 포인터를 움직일 때</li>
                <li>onmousedown : 마우스 버튼을 눌렀을 때</li>
                <li>onmouseup : 마우스를 누르고 손을 뗄 때</li>
                <li>onwheel : 휠 이벤트</li>
            </ul>
        </li>
        <li>키보드 이벤트
            <ul>
                <li>onkeypress : 키를 누를 때</li>
                <li>onkeydown : 키를 누르는 동안</li>
                <li>onkeyup : 눌렀던 키가 올라올 때 (손을 뗄 때)</li>
                <li>keypress, keydown 구분이 어려워 보통 keyup을 많이 사용</li>
            </ul>
        </li>
        <li>포커스 이벤트
            <ul>
                <li>onfocus : 요소에 포커스(커서, 포인터)가 되면</li>
                <li>onblur : 요소가 포커스를 잃으면</li>
            </ul>
        </li>
        <li>폼 이벤트
            <ul>
                <li>onsubmit : 폼 전송될 때</li>
                <li>reset : 폼 요소 값의 초기화</li>
            </ul>
        </li>
        <li>문서 관련 이벤트
            <ul>
                <li>onload : 문서 로딩이 끝나면</li>
                <li>resize : 문서 화면의 크기가 변경될 때</li>
                <li>scroll : 화면이 스크롤 되면 발생</li>
                <li>abort : 문서를 완전히 로딩되기 전에 멈춘다</li>
                <li>error : 문서가 정확히 로딩되지 않고 에러가 발생한 경우</li>
                <li>unload : 문서를 벗어날 때 발생</li>
            </ul>
        </li>
    </ul>

    <p>이벤트 처리기(이벤트 핸들러) : 웹 문서에서 이벤트가 발생 시 처리하는 함수</p>
</body>
</html>